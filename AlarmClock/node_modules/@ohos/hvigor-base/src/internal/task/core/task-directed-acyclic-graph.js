"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.projectTaskDag=exports.TaskDirectedAcyclicGraph=void 0;const multi_map_js_1=require("../../../util/multi-map.js");class TaskDirectedAcyclicGraph{constructor(){this._out=new multi_map_js_1.MultiMap,this._in=new multi_map_js_1.MultiMap}addNode(t){this._out.put(t),this._in.put(t)}addEdge(t,e){return!this._hasEdge(e,t)&&(this._out.put(t,e),this._out.put(e),this._in.put(e,t),this._in.put(t),!0)}_hasEdge(t,e){if(t===e)return!0;const s=this._out.get(t);for(const t of s)if(this._hasEdge(t,e))return!0;return!1}removeNode(t){const e=this._out.removeAll(t);for(const s of e)this._in.remove(s,t);const s=this._in.removeAll(t);for(const e of s)this._out.remove(e,t)}clear(){this._out.clear(),this._in.clear()}getChildren(t){return this._out.get(t)}getAllStartNodes(){return this.findAllZeroEdgeNodes(this._in)}getAllEndNodes(){return this.findAllZeroEdgeNodes(this._out)}findAllZeroEdgeNodes(t){const e=new Set;return t.keys().map((s=>{0===t.get(s).size&&e.add(s)})),e}}exports.TaskDirectedAcyclicGraph=TaskDirectedAcyclicGraph,exports.projectTaskDag=new TaskDirectedAcyclicGraph;