"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,s){void 0===s&&(s=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,s,i)}:function(e,t,r,s){void 0===s&&(s=r),e[s]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&__createBinding(t,e,r);return __setModuleDefault(t,e),t},__importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Clean=void 0;const fs=__importStar(require("fs")),path_1=__importDefault(require("path")),module_task_service_js_1=require("../service/module-task-service.js"),hvigor_base_1=require("@ohos/hvigor-base"),ohos_logger_js_1=require("../../utils/log/ohos-logger.js"),task_names_1=require("./task-names");class Clean extends hvigor_base_1.DefaultTask{constructor(e,t){super(e,task_names_1.TaskNames.CommonTask.CLEAN),this._logger=ohos_logger_js_1.OhosLogger.getLogger(Clean.name),this.registryAction=()=>this.clean,this.clean=()=>{let e;if(this._taskService instanceof module_task_service_js_1.ModuleTaskService){const t=this._taskService.getModuleModel();if(!t)return;e=path_1.default.resolve(t.getProjectDir(),"build")}else e=path_1.default.resolve(this._taskService.getProjectModel().getProjectDir(),"build");let t=!1;fs.existsSync(e)&&(t=this.rmdirSync(e,!1)),t&&process.exit(-1)},this.rmdirSync=(e,t)=>{fs.readdirSync(e).forEach((r=>{const s=path_1.default.resolve(e,r),i=fs.statSync(s);if(i.isFile())try{fs.unlinkSync(s)}catch(e){this._logger.debug(e.message),this._logger.warn(`Unable to delete ${s}. A file may be open by another program.`),t=!0}else i.isDirectory()&&(t=this.rmdirSync(s,t))}));try{let t=!0;fs.readdirSync(e).forEach((r=>{const s=path_1.default.resolve(e,r);fs.existsSync(s)&&(t=!1)})),t&&fs.rmdirSync(e)}catch(r){this._logger.debug(r.message),this._logger.warn(`Unable to delete ${e}. A file may be open by another program.`),t=!0}return t},this._taskService=t}}exports.Clean=Clean;